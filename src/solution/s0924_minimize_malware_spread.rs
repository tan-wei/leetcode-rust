/**
 * [0924] Minimize Malware Spread
 *
 * You are given a network of n nodes represented as an n x n adjacency matrix graph, where the i^th node is directly connected to the j^th node if graph[i][j] == 1.
 * Some nodes initial are initially infected by malware. Whenever two nodes are directly connected, and at least one of those two nodes is infected by malware, both nodes will be infected by malware. This spread of malware will continue until no more nodes can be infected in this manner.
 * Suppose M(initial) is the final number of nodes infected with malware in the entire network after the spread of malware stops. We will remove exactly one node from initial.
 * Return the node that, if removed, would minimize M(initial). If multiple nodes could be removed to minimize M(initial), return such a node with the smallest index.
 * Note that if a node was removed from the initial list of infected nodes, it might still be infected later due to the malware spread.
 *  
 * Example 1:
 * Input: graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]
 * Output: 0
 * Example 2:
 * Input: graph = [[1,0,0],[0,1,0],[0,0,1]], initial = [0,2]
 * Output: 0
 * Example 3:
 * Input: graph = [[1,1,1],[1,1,1],[1,1,1]], initial = [1,2]
 * Output: 1
 *  
 * Constraints:
 *
 * 	n == graph.length
 * 	n == graph[i].length
 * 	2 <= n <= 300
 * 	graph[i][j] is 0 or 1.
 * 	graph[i][j] == graph[j][i]
 * 	graph[i][i] == 1
 * 	1 <= initial.length <= n
 * 	0 <= initial[i] <= n - 1
 * 	All the integers in initial are unique.
 *
 */
pub struct Solution {}

// problem: https://leetcode.com/problems/minimize-malware-spread/
// discuss: https://leetcode.com/problems/minimize-malware-spread/discuss/?currentPage=1&orderBy=most_votes&query=

// submission codes start here

struct UnionFind {
    parents: Vec<usize>,
    ranks: Vec<usize>,
}

impl UnionFind {
    pub fn new(size: usize) -> Self {
        Self {
            parents: (0..size).collect(),
            ranks: vec![0; size],
        }
    }

    pub fn find(&mut self, key: usize) -> usize {
        if self.parents[key] == key {
            return key;
        }

        let parent = self.find(self.parents[key]);
        self.parents[key] = parent;
        parent
    }

    pub fn union(&mut self, x: usize, y: usize) -> bool {
        let px = self.find(x);
        let py = self.find(y);

        if px == py {
            return false;
        }

        let rx = self.ranks[px];
        let ry = self.ranks[py];

        match rx.cmp(&ry) {
            std::cmp::Ordering::Less => self.parents[px] = py,
            std::cmp::Ordering::Greater => self.parents[py] = px,
            std::cmp::Ordering::Equal => {
                self.parents[px] = py;
                self.ranks[py] += 1;
            }
        }

        true
    }
}

impl Solution {
    pub fn min_malware_spread(graph: Vec<Vec<i32>>, initial: Vec<i32>) -> i32 {
        let mut uf = UnionFind::new(graph.len());

        // Connect all linked nodes, similar to "number of islands"
        for r in 0..graph.len() {
            for c in 0..graph[r].len() {
                if graph[r][c] == 1 {
                    uf.union(r, c);
                }
            }
        }

        // Find out the size of each group of connected nodes
        let mut group_size = vec![0; graph.len()];
        for node in 0..graph.len() {
            group_size[uf.find(node)] += 1;
        }

        // Track how many initial nodes there are per group
        // because if there are more than one nodes, the whole
        // group will become infected regardless if we remove
        // one of the nodes.
        //
        // Therefore we need to find the largest group that has
        // exactly one initial node, because if we remove that node
        // then the whole group will be saved and avoid infection.
        //
        // If there are no such groups the we have to return the smallest
        // node id from the initial nodes
        let mut min_initial = initial[0];
        let mut infected_per_group = vec![0; graph.len()];
        for &node in initial.iter() {
            infected_per_group[uf.find(node as usize)] += 1;
            min_initial = node.min(min_initial);
        }

        let mut selected = min_initial;
        let mut largest_group_size = 0;

        // Process again all initially infected nodes
        for &node in initial.iter() {
            // Find the root of the group that will be infected by this node
            let group_id = uf.find(node as usize);

            // Consider the node only if there aren't any other infected
            // nodes belonging to this group, because if there are, the group
            // will be infected regardless of whether we remove this node, thus
            // we will minimize the infection if and only if this is the only
            // infected node in the group
            if infected_per_group[group_id] == 1 {
                if group_size[group_id] > largest_group_size {
                    // find the largest group
                    largest_group_size = group_size[group_id];
                    selected = node;
                } else if group_size[group_id] == largest_group_size {
                    // in case there are multiple groups with the same size
                    // select the one with smaller initially infected node number
                    selected = selected.min(node);
                }
            }
        }

        selected
    }
}

// submission codes end

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_0924_example_1() {
        let graph = vec![vec![1, 1, 0], vec![1, 1, 0], vec![0, 0, 1]];
        let initial = vec![0, 1];
        let result = 0;

        assert_eq!(Solution::min_malware_spread(graph, initial), result);
    }

    #[test]
    fn test_0924_example_2() {
        let graph = vec![vec![1, 0, 0], vec![0, 1, 0], vec![0, 0, 1]];
        let initial = vec![0, 2];
        let result = 0;

        assert_eq!(Solution::min_malware_spread(graph, initial), result);
    }

    #[test]
    fn test_0924_example_3() {
        let graph = vec![vec![1, 1, 1], vec![1, 1, 1], vec![1, 1, 1]];
        let initial = vec![1, 2];
        let result = 1;

        assert_eq!(Solution::min_malware_spread(graph, initial), result);
    }

    #[test]
    fn test_0924_additional_1() {
        let graph = vec![vec![1, 1, 0], vec![1, 1, 0], vec![0, 0, 1]];
        let initial = vec![0, 1, 2];
        let result = 2;

        assert_eq!(Solution::min_malware_spread(graph, initial), result);
    }
}
